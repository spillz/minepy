try:
    import cPickle as pickle
except ImportError:
    import pickle
import numpy

#database interface
import leveldb

# local imports
from config import SECTOR_SIZE, SECTOR_HEIGHT, LOADED_SECTORS
from util import normalize, sectorize
from blocks import BLOCK_ID

class SectorDB(object):
    def __init__(self, filename):
        self.db = leveldb.LevelDB(filename)

    def get(self, key):
        return pickle.loads(self.db.Get(key))
        
    def put(self, key, value):
        return self.db.Put(key, pickle.dumps(value, -1))

    def get_sector(self, position):
        try:
            return pickle.loads(self.db.Get(self.sector_position_to_string(position)))
        except KeyError:
            return None

    def put_sector(self, position, data):
        data = pickle.dumps(data, -1)
        self.db.Put(self.sector_position_to_string(position), data)

    def string_to_sector_position(self, str_position):
        p = str_position.split(':')
        return (p[0], 0 , p[1])

    def sector_position_to_string(self, sector_position):
        return str(sector_position[0]) + ':' + str(sector_position[2])

class Sector(object):
    def __init__(self, position, db):
        self.db = db
        if self.db is not None:
            self.blocks = self.db.get_sector(position)
        else:
            self.blocks = None
        self.position = position[0],0,position[2]
        self.bposition = position[0]-1,0,position[2]-1 #block relative position (the sector is overgenerated by one block along each x,z edge)

#        self.vt_data = None
#        self.exposed = None

    def __getitem__(self, position):
        pos = position - numpy.array(self.bposition)
        if len(pos.shape)>1:
            pos = pos.T
            return self.blocks[pos[0],pos[1],pos[2]]
        return self.blocks[pos[0],pos[1],pos[2]]

    def __setitem__(self, position, value):
        pos = position - numpy.array(self.bposition)
        if len(pos.shape)>1:
            pos = pos.T
        if self.blocks == None:
            self.blocks = {}
        self.blocks[pos[0],pos[1],pos[2]] = value
        if self.db is not None:
            self.db.put_sector(self.position, self.blocks)

    def set_block(self, position, block_id):
        """ Set a block in the sector at `position` to `block_id`.

        Parameters
        ----------
        position : tuple of len 3
            The (x, y, z) position of the block to add.
        texture : list of len 3
            The coordinates of the texture squares. Use `tex_coords()` to
            generate.
        """
        self[position] = block_id


class World(object):
    '''
    Stores data about the world
    '''

    def __init__(self):
#        mapgen.initialize_map_generator()
        # The world is stored in sector chunks.
        self.sectors = {}
        self.sector_cache = []
        self.db = SectorDB('world.db')

    def __getitem__(self, position):
        """
        retrieves the block at the (x,y,z) coordinate tuple `position`
        """
        try:
            return self.getsector(sectorize(position))[position]
        except:
            return None

    def get_sector(self, sector_position):
        sector_position = sectorize(sector_position)
        if sector_position in self.sectors:
            return self.sectors
        s = Sector(sector_position, db)
        self.sectors[sector_position] = s
        return s

    def neighbor_sectors(self, pos):
        """
        return a tuple (dx, dz, sector) of currently loaded neighbors to the sector at pos
        """
        pos = sectorize(pos)
        for x in ((-1,0),(1,0),(0,-1),(0,1)):
            npos = (pos[0]+x[0]*SECTOR_SIZE,0,pos[2]+x[1]*SECTOR_SIZE)
            if npos in self.sectors:
                yield x[0],x[1],self.sectors[npos]

    def get_sector_data(self, spos):
        #TODO: Free up unneeded sectors
        spos = sectorize(spos)
        if spos in self.sectors:
            return self.sectors[spos].blocks
        else:
            s = Sector(spos, self.db)
            self.sectors[spos] = s
            return s.blocks

    def set_block(self, position, block):
        position = normalize(position)
        spos = sectorize(position)
        result = []
        result.append(self._set_block(spos, position, block))
        if position[0] - spos[0] == 0:
            nspos = sectorize((position[0]-1, position[1], position[2]))
            result.append(self._set_block(nspos, position, block))
        if position[0] - spos[0] == SECTOR_SIZE-1:
            nspos = sectorize((position[0]+1, position[1], position[2]))
            result.append(self._set_block(nspos, position, block))
        if position[2] - spos[2] == 0:
            nspos = sectorize((position[0], position[1], position[2]-1))
            result.append(self._set_block(nspos, position, block))
        if position[2] - spos[2] == SECTOR_SIZE-1:
            nspos = sectorize((position[0], position[1], position[2]+1))
            result.append(self._set_block(nspos, position, block))
        return result

    def _set_block(self, spos, position, block):
        s = self.sectors[spos]
        s.set_block(position, block)
        return spos, s.blocks

    def get_seed(self):
        try:
            seed = self.db.get('world_seed')
            return seed
        except:
            seed = int(numpy.random.rand()*1000000)
            self.db.put('world_seed', seed)
            return seed

    def set_seed(self, seed):
        return self.db.put('world_seed', seed)
