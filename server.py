# standard library imports
import math
import itertools
import time
import numpy
import select
import cPickle
import multiprocessing.connection
import socket
import sys

# local imports
from config import SECTOR_SIZE, SECTOR_HEIGHT, LOADED_SECTORS, SERVER_IP, SERVER_PORT
from util import normalize, sectorize, FACES, cube_v, cube_v2
from blocks import BLOCK_VERTICES, BLOCK_COLORS, BLOCK_NORMALS, BLOCK_TEXTURES, BLOCK_ID, BLOCK_SOLID, TEXTURE_PATH
import mapgen

def get_network_ip():
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    s.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
    s.connect(('<broadcast>', 0))
    return s.getsockname()[0]


SECTOR_GRID = numpy.mgrid[:SECTOR_SIZE,:SECTOR_HEIGHT,:SECTOR_SIZE].T
SH = SECTOR_GRID.shape
SECTOR_GRID = SECTOR_GRID.reshape((SH[0]*SH[1]*SH[2],3))

class Sector(object):
    def __init__(self,position,model):
        self.position = position[0],0,position[2]
        self.bposition = position[0]-1,0,position[2]-1 #block relative position (the sector is overgenerated by one block along each x,z edge)
        self.model = model
        self.blocks = numpy.zeros((SECTOR_SIZE+2,SECTOR_HEIGHT,SECTOR_SIZE+2),dtype='u2')

        self.vt_data = None
        self.exposed = None

    def __getitem__(self, position):
        pos = position - numpy.array(self.bposition)
        if len(pos.shape)>1:
            pos = pos.T
            return self.blocks[pos[0],pos[1],pos[2]]
        return self.blocks[pos[0],pos[1],pos[2]]

    def __setitem__(self, position, value):
        pos = position - numpy.array(self.bposition)
        if len(pos.shape)>1:
            pos = pos.T
        self.blocks[pos[0],pos[1],pos[2]] = value

    def set_block(self, position, block_id):
        """ Set a block in the sector at `position` to `block_id`.

        Parameters
        ----------
        position : tuple of len 3
            The (x, y, z) position of the block to add.
        texture : list of len 3
            The coordinates of the texture squares. Use `tex_coords()` to
            generate.
        """
        self[position] = block_id

    def _initialize(self):
        """ Initialize the sector by procedurally generating terrain using
        simplex noise.

        """
        self.blocks = mapgen.generate_sector(self.position, None, None)


class Model(object):

    def __init__(self):
        mapgen.initialize_map_generator()
        # The world is stored in sector chunks.
        self.sectors = {}
        self.sector_cache = []

        # Simple function queue implementation. The queue is populated with
        # _show_block() and _hide_block() calls
#        self.queue = deque()

#        d = range(-SECTOR_SIZE*3,SECTOR_SIZE*3+1,SECTOR_SIZE)
#        #d = range(-128,128+1,SECTOR_SIZE)
#        for pos in itertools.product(d,(0,),d):
#            s=Sector(pos, self)
#            self.sectors[sectorize(pos)] = s
#            s._initialize()
#        for s in self.sectors:
#            self.sectors[s].calc_vertex_data()


    def __getitem__(self, position):
        """
        retrieves the block at the (x,y,z) coordinate tuple `position`
        """
        try:
            return self.sectors[sectorize(position)][position]
        except:
            return None

    def neighbor_sectors(self, pos):
        """
        return a tuple (dx, dz, sector) of currently loaded neighbors to the sector at pos
        """
        pos = sectorize(pos)
        for x in ((-1,0),(1,0),(0,-1),(0,1)):
            npos = (pos[0]+x[0]*SECTOR_SIZE,0,pos[2]+x[1]*SECTOR_SIZE)
            if npos in self.sectors:
                yield x[0],x[1],self.sectors[npos]

    def change_sectors(self, old, new):
        """
        the observer has moved from sector old to new
        """
        if self.thread == None:
            self.thread = threading.Thread(target = self._load_sectors, args = (set(self.sectors),new))
            self.thread.start()

    def request_sector(self, spos):
        spos = sectorize(spos)
        return self.sectors[spos].block_data

    def set_block(self, position, block):
        position = normalize(position)
        spos = sectorize(position)
        result = []
        result.append(self._set_block(spos, position, block))
        if position[0] - spos[0] == 0:
            nspos = sectorize((position[0]-1, position[1], position[2]))
            result.append(self._set_block(nspos, position, block))
        if position[0] - spos[0] == SECTOR_SIZE-1:
            nspos = sectorize((position[0]+1, position[1], position[2]))
            result.append(self._set_block(nspos, position, block))
        if position[2] - spos[2] == 0:
            nspos = sectorize((position[0], position[1], position[2]-1))
            result.append(self._set_block(nspos, position, block))
        if position[2] - spos[2] == SECTOR_SIZE-1:
            nspos = sectorize((position[0], position[1], position[2]+1))
            result.append(self._set_block(nspos, position, block))
        return result

    def _set_block(self, spos, position, block):
        if spos not in self.sectors:
            return None
        s = self.sectors[spos]
        s.set_block(position, block)
        return spos, s.blocks

    def hit_test(self, position, vector, max_distance=8):
        """ Line of sight search from current position. If a block is
        intersected it is returned, along with the block previously in the line
        of sight. If no block is found, return None, None.

        Parameters
        ----------
        position : tuple of len 3
            The (x, y, z) position to check visibility from.
        vector : tuple of len 3
            The line of sight vector.
        max_distance : int
            How many blocks away to search for a hit.

        """
        m = 8
        x, y, z = position
        dx, dy, dz = vector
        previous = None
        for _ in xrange(max_distance * m):
            key = normalize((x, y, z))
            if key != previous:
                b = self[key]
                if b != 0 and b is not None:
                    return key, previous
            previous = key
            x, y, z = x + dx / m, y + dy / m, z + dz / m
        return None, None

    def exposed(self, position):
        """ Returns False is given `position` is surrounded on all 6 sides by
        blocks, True otherwise.

        """
        x, y, z = position
        for dx, dy, dz in FACES:
            b = self[normalize((x + dx, y + dy, z + dz))]
            if not BLOCK_SOLID[b]:
                return True
        return False

    def check_neighbors(self, position):
        """ Check all blocks surrounding `position` and ensure their visual
        state is current. This means hiding blocks that are not exposed and
        ensuring that all exposed blocks are shown. Usually used after a block
        is added or removed.

        """
        x, y, z = position
        for dx, dy, dz in FACES:
            key = (x + dx, y + dy, z + dz)
            b = self[key]
            if not BLOCK_SOLID[b] or b is None:
                continue
#            self.update_block(key)
            self.sectors[sectorize(key)].update_block(key)

class Player(object):
    def __init__(self, conn):
        self.conn = conn
        self.name = 'FRED'
        self.position = (0,0,0)
        self.comms_queue = []
    def __repr__(self):
        print self.name

class Server(object):
    def __init__(self):
        print('starting server at %s:%i'%(SERVER_IP,SERVER_PORT))
        self.listener = multiprocessing.connection.Listener(address = (SERVER_IP,SERVER_PORT), authkey = 'password')
        self.players = []
        self.world = Model()

    def connections(self):
        return [p.conn for p in self.players]

    def player_from_connection(self, conn):
        for p in self.players:
            if conn == p.conn:
                return p

    def accept_connection(self):
        conn = self.listener.accept()
        self.players.append(Player(conn))
        return conn

    def serve(self):
        alive = True
        while alive:
            r,w,x = select.select([self.listener._listener._socket] + self.connections(), [], [])
            accept_new = True
            for p in self.players:
                if p.conn in r:
                    other_players = [op for op in self.players if op!=p]
                    accept_new = False
                    print('recv from',p.name)
                    try:
                        msg, data = conn.recv()
                        print('msg',msg)
                        if msg == 'set_name':
                            used = False
                            for op in other_players:
                                if op.name == name:
                                    used = True
                            if not used:
                                p.name = data
                            p.conn.send_bytes(cPickle.dumps(['set_name', p.name],-1))
                        if msg == 'request_sector':
                            spos = data
                            blocks = self.world.request_sector(spos)
                            print('sending sector data',spos)
                            p.conn.send_bytes(cPickle.dumps([spos, blocks],-1))
                        if msg == 'set_position':
                            p.position = data
                            print('sending player position',p.name,p.position)
                            for po in other_players: #notify other players
                                p.conn.send_bytes(cPickle.dumps(['set_position',[p.name,p.position]],-1))
                        if msg == 'set_block':
                            pos, block = data
                            self.world.set_block(pos, block)
                            for p0 in self.players: #notify ALL players
                                p0.conn.send_bytes(cPickle.dumps(['set_block',pos, block],-1))
                        if msg == 'quit':
                            alive = False
                    except EOFError:
                        p = self.player_from_connection(conn)
                        print('lost',p)
                        self.players.remove(p)
            if accept_new:
                conn = self.accept_connection()
                print('accept',conn)
        self.listener.close()

if __name__ == '__main__':
    SERVER_IP = 'localhost'
    if len(sys.argv)>1:
        if sys.argv[1] == 'LAN':
            SERVER_IP = get_network_ip()
    #TODO: use a config file for server settings
    #TODO: use argparse module to override default server settings
    s = Server()
    s.serve()
