# standard library imports
import time
import numpy
import select
import cPickle
import multiprocessing.connection
import socket
import sys
import traceback

#database interface
import leveldb

# local imports
from config import SECTOR_SIZE, SECTOR_HEIGHT, LOADED_SECTORS, SERVER_IP, SERVER_PORT
from util import normalize, sectorize, FACES
from blocks import BLOCK_ID
from players import Player, ClientPlayer
#import mapgen

def get_network_ip():
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    s.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
    s.connect(('<broadcast>', 0))
    return s.getsockname()[0]

class SectorDB(object):
    def __init__(self, filename):
        self.db = leveldb.LevelDB(filename)
        
    def get_sector(self, position):
        try:
            return cPickle.loads(self.db.Get(self.sector_position_to_string(position)))
        except KeyError:
            return None
        
    def put_sector(self, position, data):
        data = cPickle.dumps(data, -1)
        self.db.Put(self.sector_position_to_string(position), data)
        
    def string_to_sector_position(self, str_position):
        p = str_position.split(':')
        return (p[0], 0 , p[1])
        
    def sector_position_to_string(self, sector_position):
        return str(sector_position[0]) + ':' + str(sector_position[2])

class Sector(object):
    def __init__(self, position, db):
        self.db = db
        if self.db is not None:
            self.blocks = self.db.get_sector(position)
        else:
            self.blocks = None
        self.position = position[0],0,position[2]
        self.bposition = position[0]-1,0,position[2]-1 #block relative position (the sector is overgenerated by one block along each x,z edge)

#        self.vt_data = None
#        self.exposed = None

    def __getitem__(self, position):
        pos = position - numpy.array(self.bposition)
        if len(pos.shape)>1:
            pos = pos.T
            return self.blocks[pos[0],pos[1],pos[2]]
        return self.blocks[pos[0],pos[1],pos[2]]

    def __setitem__(self, position, value):
        pos = position - numpy.array(self.bposition)
        if len(pos.shape)>1:
            pos = pos.T
        if self.blocks == None:
            self.blocks = {}
        self.blocks[pos[0],pos[1],pos[2]] = value
        if self.db is not None:
            self.db.put_sector(self.position, self.blocks)

    def set_block(self, position, block_id):
        """ Set a block in the sector at `position` to `block_id`.

        Parameters
        ----------
        position : tuple of len 3
            The (x, y, z) position of the block to add.
        texture : list of len 3
            The coordinates of the texture squares. Use `tex_coords()` to
            generate.
        """
        self[position] = block_id


class World(object):
    '''
    Stores data about the world
    '''

    def __init__(self):
#        mapgen.initialize_map_generator()
        # The world is stored in sector chunks.
        self.sectors = {}
        self.sector_cache = []
        self.db = SectorDB('world.db')

    def __getitem__(self, position):
        """
        retrieves the block at the (x,y,z) coordinate tuple `position`
        """
        try:
            return self.getsector(sectorize(position))[position]
        except:
            return None

    def get_sector(self, sector_position):
        sector_position = sectorize(sector_position)
        if sector_position in self.sectors:
            return self.sectors
        s = Sector(sector_position, db)
        self.sectors[sector_position] = s
        return s

    def neighbor_sectors(self, pos):
        """
        return a tuple (dx, dz, sector) of currently loaded neighbors to the sector at pos
        """
        pos = sectorize(pos)
        for x in ((-1,0),(1,0),(0,-1),(0,1)):
            npos = (pos[0]+x[0]*SECTOR_SIZE,0,pos[2]+x[1]*SECTOR_SIZE)
            if npos in self.sectors:
                yield x[0],x[1],self.sectors[npos]

    def get_sector_data(self, spos):
        #TODO: Free up unneeded sectors
        spos = sectorize(spos)
        if spos in self.sectors:               
            return self.sectors[spos].blocks
        else:
            s = Sector(spos, self.db)
            self.sectors[spos] = s
            return s.blocks

    def set_block(self, position, block):
        position = normalize(position)
        spos = sectorize(position)
        result = []
        result.append(self._set_block(spos, position, block))
        if position[0] - spos[0] == 0:
            nspos = sectorize((position[0]-1, position[1], position[2]))
            result.append(self._set_block(nspos, position, block))
        if position[0] - spos[0] == SECTOR_SIZE-1:
            nspos = sectorize((position[0]+1, position[1], position[2]))
            result.append(self._set_block(nspos, position, block))
        if position[2] - spos[2] == 0:
            nspos = sectorize((position[0], position[1], position[2]-1))
            result.append(self._set_block(nspos, position, block))
        if position[2] - spos[2] == SECTOR_SIZE-1:
            nspos = sectorize((position[0], position[1], position[2]+1))
            result.append(self._set_block(nspos, position, block))
        return result

    def _set_block(self, spos, position, block):
        s = self.sectors[spos]
        s.set_block(position, block)
        return spos, s.blocks

class ServerConnectionHandler(object):
    '''
    Handles the low level connection handling details of the multiplayer server
    '''
    def __init__(self):
        print('starting server at %s:%i'%(SERVER_IP,SERVER_PORT))
        self.listener = multiprocessing.connection.Listener(address = (SERVER_IP,SERVER_PORT), authkey = 'password')
        self.players = []
        self.fn_dict = {}

    def register_function(self, name, fn):
        self.fn_dict[name]=fn

    def call_function(self,name,*args):
        return self.fn_dict[name](*args)

    def connections(self):
        return [p.conn for p in self.players]

    def connections_with_comms(self):
        return [p.conn for p in self.players if len(p.comms_queue)>0]

    def player_from_connection(self, conn):
        for p in self.players:
            if conn == p.conn:
                return p

    def accept_connection(self):
        conn = self.listener.accept()
        player = Player(conn)
        self.players.append(player)
        return player

    def serve(self):
        alive = True
        while alive:
            r,w,x = select.select([self.listener._listener._socket] + self.connections(), self.connections_with_comms(), [])
            accept_new = True
            for p in self.players:
                if p.conn in r:
                    other_players = [op for op in self.players if op!=p]
                    accept_new = False
                    print('recv from',p.name)
                    try:
                        msg, data = p.conn.recv()
                        print('msg',msg,data)
                        if msg == 'quit':
                            alive = False
                        else:
                            try:
                                self.call_function(msg, player, *data)
                            except Exception as ex:
                                traceback.print_exc()
                    except EOFError:
                        print('lost',p)
                        self.players.remove(p)
            if accept_new and self.listener._listener._socket in r:
                player = self.accept_connection()
                print('connected',player)
                self.queue_for_player(player, 'connected', ClientPlayer(player), [ClientPlayer(p) for p in self.players])
                self.queue_for_others(player, 'other_player_join', ClientPlayer(player))
            for p in self.players:
                if p.conn in w:
                    self.dispatch_top_message(p)
        self.listener.close()

    ##TODO: queue calls should collapse similar calls (e.g. multiple block adds in the same sector)
    ##TODO: prioritize calls
    def queue_for_player(self, player, message, *data):
        player.comms_queue.append([message, player.id, data])

    def queue_for_others(self, player, message, *data):
        for p in self.players:
            if p != player:
                p.comms_queue.append([message, player.id, data])

    def queue_for_all_players(self, player, message, *data):
        for p in self.players:
            p.comms_queue.append([message, player.id, data])

    def other_players(self, player):
        return [p for p in self.players if p != player]

    def dispatch_top_message(self, player):
        print('sending',player,player.comms_queue[0])
        player.conn.send_bytes(cPickle.dumps(player.comms_queue.pop(0), -1))

class Server(object):
    '''
    minepy Multiplayer Server
    manages connections from players and handles data requests

    Maintains the following databases
        block information (delta from what the terrain generator produces)
        player information (unique id/name, location, velocity)

    Server Messages (client must have handlers for these)
        connected(players)
            notifies the player that just connect with a list of all `players`
        other_player_join(player)
            notifies all other players that `player` has joined
        player_set_name(player, name)
            notifies all players that `player` is using name `name`
        player_set_position(player, position)
            notifies all other players that `player` is at `position`
        player_set_block(player, position, block)
            notifies all players that `player` has set `block` at `position`
        updated_sector_blocks(sector_pos, sector_blocks_delta)
            sends `sector_blocks_delta` to the player that requested it
    '''
    def __init__(self):
        self.handler = ServerConnectionHandler()
        self.world = World()
        #TODO: could use a decorator to avoid explicit registration, though I think this is more readable
        self.handler.register_function('set_name',self.set_name)
        self.handler.register_function('set_postion',self.set_position)
        self.handler.register_function('set_block',self.set_block)
        self.handler.register_function('sector_blocks',self.sector_blocks)
        self.handler.serve()

    def set_name(self, player, name):
        '''
        sets the unique name for the player
        player's client must wait for the confirmation player_set_name message from
        the server before assuming the name
        '''
        used = False
        for op in self.handler.other_players(player):
            if op.name == name:
                used = True
        if not used:
            player.name = data
        self.handler.queue_for_all_players(player, 'player_set_name', player.name)

    def set_position(self, player, position):
        '''
        sets the `position` tuple for the `player`
        confirmation is not required, player_set_position message is
        broadcast only to other players
        '''
        player.position = position
        self.handler.queue_for_others(player, 'player_set_position', position)

    def set_block(self, player, position, block):
        '''
        sets the block at `position` to the id given by `block`
        player's client must wait for the confirmation `player_set_name` message from
        the server before assuming the block has been set (to avoid synchronization issues
        when multiple players set the same block)
        '''
        self.world.set_block(position, block)
        self.handler.queue_for_all_players(player, 'player_set_block', position, block)

    def sector_blocks(self, player, sector_pos):
        '''
        request by `player` for the changed blocks in `sector_pos`
        data will be sent with the message `sector_blocks`
        '''
        blocks = self.world.get_sector_data(sector_pos)
        self.handler.queue_for_player(player, 'sector_blocks_changed', sector_pos, blocks)



if __name__ == '__main__':
    #TODO: use a config file for server settings
    #TODO: use argparse module to override default server settings
    SERVER_IP = 'localhost'
    if len(sys.argv)>1:
        if sys.argv[1] == 'LAN':
            SERVER_IP = get_network_ip()
    s = Server()
